-- WindUI rewrite of the Vuzez || Universal script (was Orion)

local player = game.Players.LocalPlayer
local mouse = player:GetMouse()

-- remove anti/afk localscripts the game might inject
do
    local scriptsFolder = player:FindFirstChild("PlayerScripts")
    if scriptsFolder then
        for _, name in ipairs({ "AFK", "Anti", "AE" }) do
            local inst = scriptsFolder:FindFirstChild(name)
            if inst then
                inst:Destroy()
            end
        end
    end
end

-- load WindUI
local WindUI
do
    local ok, result = pcall(function()
        return require("./src/Init")
    end)
    if ok then
        WindUI = result
    else
        WindUI = loadstring(game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua"))()
    end
end

-- PATCH: Fix WindUI Icons crash (missing .Icons table in 'solar' pack)
if WindUI and WindUI.Creator and WindUI.Creator.Icons and WindUI.Creator.Icons.Icons then
    local solar = WindUI.Creator.Icons.Icons["solar"]
    if solar then
        if not solar.Icons then solar.Icons = {} end
        if not solar.Spritesheets then solar.Spritesheets = {} end
    end
end


-- compatibility: add dummy :Connect on RBXScriptConnection to avoid crashes in third-party modules
do
    local tmp = game:GetService("RunService").Heartbeat:Connect(function() end)
    local mt = getmetatable(tmp)
    tmp:Disconnect()
    if mt and mt.__index then
        local oldIndex = mt.__index
        pcall(function()
            setreadonly(mt, false)
            mt.__index = function(self, key)
                if key == "Connect" or key == "connect" then
                    return function(_, _cb)
                        -- if a script tries to :Connect on a connection, just return the connection itself
                        return self
                    end
                end
                return oldIndex(self, key)
            end
            setreadonly(mt, true)
        end)
    end
end

-- tween safety: coerce NumberSequence properties when goals use plain numbers
local function coerceGoals(instance, goals)
    local fixed = {}
    for prop, value in pairs(goals or {}) do
        local current = instance and instance[prop]
        if typeof(current) == "NumberSequence" and type(value) == "number" then
            fixed[prop] = NumberSequence.new(value)
        else
            fixed[prop] = value
        end
    end
    return fixed
end

do
    local TweenService = game:GetService("TweenService")
    local rawCreate

    local function forceNumberSequences(goals)
        local fixed = {}
        for prop, value in pairs(goals or {}) do
            if type(value) == "number" then
                fixed[prop] = NumberSequence.new(value)
            else
                fixed[prop] = value
            end
        end
        return fixed
    end

    local function createSafe(self, instance, tweenInfo, goals)
        rawCreate = rawCreate or TweenService.Create
        local ok, result = pcall(rawCreate, self, instance, tweenInfo, coerceGoals(instance, goals))
        if ok then
            return result
        end
        local ok2, result2 = pcall(rawCreate, self, instance, tweenInfo, forceNumberSequences(goals))
        if ok2 then
            return result2
        end
        warn("[TweenSafe] suppressed Tween error:", result, result2)
        return {
            Play = function() end,
            Pause = function() end,
            Cancel = function() end,
        }
    end

    -- direct override (covers cached references to the function itself)
    pcall(function()
        rawCreate = rawCreate or TweenService.Create
        TweenService.Create = function(self, instance, tweenInfo, goals)
            return createSafe(self, instance, tweenInfo, goals)
        end
    end)

    -- hookfunction fallback (if available)
    pcall(function()
        rawCreate = rawCreate or TweenService.Create
        rawCreate = hookfunction(rawCreate, function(self, instance, tweenInfo, goals)
            return createSafe(self, instance, tweenInfo, goals)
        end)
    end)

    -- namecall hook (colon syntax)
    pcall(function()
        local old
        old = hookmetamethod(game, "__namecall", function(self, ...)
            local method = (getnamecallmethod and getnamecallmethod()) or ""
            if self == TweenService and method == "Create" then
                local instance, tweenInfo, goals = ...
                return TweenService.Create(self, instance, tweenInfo, goals)
            end
            return old(self, ...)
        end)
    end)

    -- metatable __index fallback
    pcall(function()
        local mt = getrawmetatable(TweenService)
        if not mt then
            return
        end
        local oldIndex = mt.__index
        setreadonly(mt, false)
        mt.__index = function(self, key)
            if key == "Create" then
                return function(_, instance, tweenInfo, goals)
                    return createSafe(self, instance, tweenInfo, goals)
                end
            end
            return oldIndex(self, key)
        end
        setreadonly(mt, true)
    end)
end

-- icons used in tabs/elements
WindUI.Creator.AddIcons("solar", {
    ["CheckSquareBold"] = "rbxassetid://132438947521974",
    ["CursorSquareBold"] = "rbxassetid://120306472146156",
    ["FolderWithFilesBold"] = "rbxassetid://74631950400584",
    ["HamburgerMenuBold"] = "rbxassetid://134384554225463",
    ["Home2Bold"] = "rbxassetid://92190299966310",
    ["SolarSquareTransferHorizontalBold"] = "rbxassetid://125444491429160",
})

local Purple = Color3.fromHex("#7775F2")
local Yellow = Color3.fromHex("#ECA201")
local Green = Color3.fromHex("#10C550")
local Grey = Color3.fromHex("#83889E")
local Blue = Color3.fromHex("#257AF7")
local Red = Color3.fromHex("#EF4F1D")

-- window
local Window = WindUI:CreateWindow({
    Title = "Vuzez || Universal",
    Folder = "idk",
    IconSize = 44,
    NewElements = true,
    HideSearchBar = false,
    OpenButton = {
        Title = "Open Vuz UI",
        CornerRadius = UDim.new(1, 0),
        StrokeThickness = 3,
        Enabled = true,
        Draggable = true,
        OnlyMobile = false,
        Color = ColorSequence.new(Color3.fromHex("#000000"), Color3.fromHex("#20201f")),
    },
    Topbar = {
        Height = 44,
        ButtonsType = "Mac",
    },
})

-- state
local keepSpeed = false
local targetWalkspeed = 20
local keepJump = false
local targetJump = 50
local npcKill = false
local tToTP = false
local instantInteract = true
local noStun = true

local tpDistance = 3
local tpDirection = "Up"
local selectedMob = nil
local autoTPMob = false
local autoM1 = false
local autoSkills = false
local selectedSkills = {"E", "R", "T", "Y", "H", "G", "Q"}

-- Config System
-- Config System
local CONFIG_FOLDER = "Vuz"
local CONFIG_FILE = CONFIG_FOLDER .. "/config.json"
local httpService = game:GetService("HttpService")

if not isfolder(CONFIG_FOLDER) then
    makefolder(CONFIG_FOLDER)
end

local function saveSettings(silent)
    local data = {
        tpDistance = tpDistance,
        tpDirection = tpDirection,
        selectedSkills = selectedSkills,
        targetWalkspeed = targetWalkspeed,
        targetJump = targetJump,
        noStun = noStun,
        instantInteract = instantInteract,
        autoM1 = autoM1,
        autoSkills = autoSkills
    }
    local success, encoded = pcall(function() return httpService:JSONEncode(data) end)
    if success then
        writefile(CONFIG_FILE, encoded)
        if not silent then
            notify("Config", "Settings saved successfully.")
        end
    else
        if not silent then
            notify("Config", "Failed to encode settings.")
        end
    end
end

local function loadSettings()
    if not isfile(CONFIG_FILE) then
        notify("Config", "No saved config found.")
        return
    end
    local success, decoded = pcall(function() return httpService:JSONDecode(readfile(CONFIG_FILE)) end)
    if success and decoded then
        if decoded.tpDistance then tpDistance = decoded.tpDistance end
        if decoded.tpDirection then tpDirection = decoded.tpDirection end
        if decoded.selectedSkills then selectedSkills = decoded.selectedSkills end
        if decoded.targetWalkspeed then targetWalkspeed = decoded.targetWalkspeed end
        if decoded.targetJump then targetJump = decoded.targetJump end
        if decoded.noStun ~= nil then noStun = decoded.noStun end
        if decoded.instantInteract ~= nil then instantInteract = decoded.instantInteract end
        notify("Config", "Settings loaded.")
    else
        notify("Config", "Failed to load settings.")
    end
end


-- Global Mob Cache Logic
local mobCache = {}
local mobNames = {}
local mobDropdownMain = nil
local mobDropdownFarm = nil

local function refreshMobs()
    table.clear(mobCache)
    table.clear(mobNames)
    
    local ignoredMobs = {
        ["Attacking Dummy"] = true,
        ["Blocking Dummy"] = true,
        ["Counter Dummy"] = true,
        ["Dummy"] = true,
        ["Tough Dummy"] = true
    }
    
    local counts = {}
    for _, v in ipairs(workspace:GetDescendants()) do
        if v:IsA("Humanoid") and v.Parent and v.Parent ~= player.Character then
            local char = v.Parent
            -- Mob filter: Must have CDValues folder OR be named "Dummy" (but we filter specific dummy names below)
            -- And MUST NOT be a player
            if (char:FindFirstChild("CDValues") or char.Name == "Dummy") and not game.Players:GetPlayerFromCharacter(char) then
                if not ignoredMobs[char.Name] then
                    local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
                    if root then
                        local name = char.Name
                        -- handle duplicates
                        if counts[name] then
                            counts[name] = counts[name] + 1
                            name = name .. " [" .. counts[name] .. "]"
                        else
                            counts[name] = 1
                        end
                        
                        mobCache[name] = root
                        table.insert(mobNames, name)
                    end
                end
            end
        end
    end
    table.sort(mobNames)
    if mobDropdownMain then mobDropdownMain:Refresh(mobNames) end
    if mobDropdownFarm then mobDropdownFarm:Refresh(mobNames) end
end

local function notify(title, content)
    WindUI:Notify({
        Title = title,
        Content = content,
    })
end

-- Home tab
local HomeTab = Window:Tab({
    Title = "Home",
    Icon = "solar:Home2Bold",
    IconColor = Grey,
    IconShape = "Square",
})

HomeTab:Section({
    Title = "Script made by Vuzz",
    TextSize = 16,
})

HomeTab:Space()

HomeTab:Button({
    Title = "Infinite Yield",
    Icon = "solar:FolderWithFilesBold",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source", true))()
    end,
})

HomeTab:Space()

HomeTab:Button({
    Title = "Self Destruct",
    Color = Red,
    Icon = "solar:CursorSquareBold",
    Callback = function()
        Window:Destroy()
    end,
})

-- Main tab
local MainTab = Window:Tab({
    Title = "Main",
    Icon = "solar:CursorSquareBold",
    IconColor = Blue,
    IconShape = "Square",
})

MainTab:Toggle({
    Title = "NPC Kill",
    Desc = "Kills all humanoids except you",
    Callback = function(value)
        npcKill = value
        task.spawn(function()
            while npcKill do
                task.wait(0.5)
                pcall(function()
                    sethiddenproperty(player, "SimulationRadius", 112412400000)
                    sethiddenproperty(player, "MaxSimulationRadius", 112412400000)
                    for _, inst in ipairs(workspace:GetDescendants()) do
                        if inst.ClassName == "Humanoid" and inst.Parent then
                            local char = inst.Parent
                            if char.Name ~= player.Name then
                                -- guard rigs missing expected parts (avoids VFX errors) and require CDValues folder
                                local hasCoreParts = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
                                local hasCD = char:FindFirstChild("CDValues")
                                if hasCoreParts and hasCD and inst.Health > 0 then
                                    inst.Health = 0
                                end
                            end
                        end
                    end
                end)
            end
        end)
    end,
})



MainTab:Space()


MainTab:Button({
    Title = "Instant Interact",
    Desc = "Sets HoldDuration of current prompts to 0",
    Callback = function()
        for _, v in ipairs(workspace:GetDescendants()) do
             if v:IsA("ProximityPrompt") then
                 v.HoldDuration = 0
             end
         end
         notify("Instant Interact", "Applied to all current prompts")
    end,
})

MainTab:Space()

MainTab:Toggle({
    Title = "No Stun",
    Desc = "Removes Stun objects/states (Aggressive)",
    Callback = function(value)
        noStun = value
        if value then
            task.spawn(function()
                while noStun do
                    if player.Character then
                        -- 1. Scan attributes
                        for name, _ in pairs(player.Character:GetAttributes()) do
                            if string.find(string.lower(name), "stun") or string.find(string.lower(name), "action") then
                                player.Character:SetAttribute(name, nil)
                            end
                        end
                        
                        -- 2. Scan descendants for stun objects
                        for _, v in ipairs(player.Character:GetDescendants()) do
                            local name = string.lower(v.Name)
                            if string.find(name, "stun") or string.find(name, "busy") or string.find(name, "nojump") or string.find(name, "nowalk") then
                                v:Destroy()
                            end
                        end

                        -- 3. Humanoid state
                        local hum = player.Character:FindFirstChild("Humanoid")
                        if hum then
                            if hum.PlatformStand then hum.PlatformStand = false end
                            if hum.Sit then hum.Sit = false end
                        end
                    end
                    task.wait(0.1)
                end
            end)
        end
    end,
})




MainTab:Space()

-- NPC Dropdown Logic
local npcCache = {}
local npcNames = {}
local npcDropdown = nil

local function refreshNPCs()
    table.clear(npcCache)
    table.clear(npcNames)
    
    local counts = {}
    for _, v in ipairs(workspace:GetDescendants()) do
        if v:IsA("Humanoid") and v.Parent and v.Parent ~= player.Character then
            local char = v.Parent
            local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Head")
            if root then
                local name = char.Name
                -- handle duplicates
                if counts[name] then
                    counts[name] = counts[name] + 1
                    name = name .. " [" .. counts[name] .. "]"
                else
                    counts[name] = 1
                end
                
                npcCache[name] = root
                table.insert(npcNames, name)
            end
        end
    end
    table.sort(npcNames)
    if npcDropdown then
        npcDropdown:Refresh(npcNames)
    end
end

MainTab:Button({
    Title = "Refresh NPC List",
    Icon = "solar:SolarSquareTransferHorizontalBold",
    Callback = refreshNPCs
})

npcDropdown = MainTab:Dropdown({
    Title = "Select NPC to TP",
    Multi = false,
    Required = false,
    Values = {},
    Callback = function(value)
        if type(value) == "table" then value = value[1] end -- handle multi-select return just in case
        if not value then return end
        
        local targetPart = npcCache[value]
        if targetPart then
            player.Character.HumanoidRootPart.CFrame = targetPart.CFrame * CFrame.new(0, 3, 0)
            notify("TP NPC", "Teleported to " .. value)
        else
            notify("TP NPC", "Target not found (refresh list?)")
        end
    end,
})



MainTab:Space()

-- Mob Dropdown Logic (uses global cache)
MainTab:Button({
    Title = "Refresh Mob List",
    Icon = "solar:SolarSquareTransferHorizontalBold",
    Callback = refreshMobs
})

mobDropdownMain = MainTab:Dropdown({
    Title = "Select Mob to TP",
    Multi = false,
    Required = false,
    Values = mobNames,
    Callback = function(value)
        if type(value) == "table" then value = value[1] end
        if not value then return end
        
        local targetPart = mobCache[value]
        if targetPart then
            player.Character.HumanoidRootPart.CFrame = targetPart.CFrame * CFrame.new(0, 3, 0)
            notify("TP Mob", "Teleported to " .. value)
        else
            notify("TP Mob", "Mob not found (refresh list?)")
        end
    end,
})


MainTab:Space()

-- Farm Tab
local FarmTab = Window:Tab({
    Title = "Farm",
    Icon = "solar:FolderWithFilesBold",
    IconColor = Green,
    IconShape = "Square",
})

-- Logic provided by user
local autoFarmEnabled = false
local autoCollectEnabled = false
local retryItems = {}
local LEVEL_ITEM_NAMES = {"Box", "Barrel"} -- Add item names here
local COLLECT_IGNORE = {"Baseplate", "SpawnLocation"}
local Workspace = workspace
local plr = player -- mapping to existing variable

local character = plr.Character or plr.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart", 5)

local function updateCharacter()
    character = plr.Character or plr.CharacterAdded:Wait()
    hrp = character:WaitForChild("HumanoidRootPart", 5)
end
plr.CharacterAdded:Connect(updateCharacter)

local function isLevelItem(itemName)
    for _, word in ipairs(LEVEL_ITEM_NAMES) do
        if string.find(string.lower(itemName), string.lower(word)) then return true end
    end
    return false
end

local function isCollectIgnored(itemName)
    for _, word in ipairs(COLLECT_IGNORE) do
        if string.lower(itemName) == string.lower(word) then return true end
    end
    return false
end

local function interactPrompt(prompt)
    if not prompt then return end
    pcall(function()
        fireproximityprompt(prompt, 1)
    end)
end

local function collectPrompt(prompt)
    if not prompt or not prompt.Parent or not hrp then return end
    local targetPart = prompt.Parent:IsA("BasePart") and prompt.Parent or prompt.Parent:FindFirstChildWhichIsA("BasePart")
    if targetPart then
        hrp.CFrame = targetPart.CFrame * CFrame.new(0, 3, 0)
        task.wait(0.1)  -- fast warp
        prompt.HoldDuration = 0
        interactPrompt(prompt)
    end
end

local function getValidLevelPrompts()
    local results = {}
    for _, v in ipairs(Workspace:GetDescendants()) do
        if v:IsA("ProximityPrompt") and v.Parent and v.Enabled and isLevelItem(v.Parent.Name) then
            table.insert(results, v)
        end
    end
    return results
end

local function tryCollectItem(item)
    if not item:IsDescendantOf(Workspace) then return false end
    if isCollectIgnored(item.Name) then return false end

    local prompt = item:FindFirstChildWhichIsA("ProximityPrompt", true)
    if not prompt or not prompt.Enabled then
        if not table.find(retryItems, item) then table.insert(retryItems, item) end
        return false
    end

    prompt.HoldDuration = 0

    local targetPart = prompt.Parent:IsA("BasePart") and prompt.Parent or item
    if hrp then
        hrp.CFrame = targetPart.CFrame * CFrame.new(0, 2, 0)
    end

    task.wait(0.1)
    interactPrompt(prompt)
    task.wait(0.05)

    if not item:IsDescendantOf(Workspace) then
        for i = #retryItems, 1, -1 do
            if retryItems[i] == item then table.remove(retryItems, i) end
        end
        return true
    else
        if not table.find(retryItems, item) then
            table.insert(retryItems, item)
        end
        return false
    end
end

-- Toggles to use the functions
FarmTab:Toggle({
    Title = "Auto Farm Level Items",
    Callback = function(value)
        autoFarmEnabled = value
        if value then
            task.spawn(function()
                while autoFarmEnabled do
                    local prompts = getValidLevelPrompts()
                    for _, p in ipairs(prompts) do
                        if not autoFarmEnabled then break end
                        collectPrompt(p)
                    end
                    task.wait(0.2)
                end
            end)
        end
    end,
})

FarmTab:Toggle({
    Title = "Auto Collect All (Risky)",
    Callback = function(value)
        autoCollectEnabled = value
        if value then
            task.spawn(function()
                while autoCollectEnabled do
                    -- Scan workspace for things that look collectable (simple scan for prompts parented to parts)
                    for _, v in ipairs(Workspace:GetDescendants()) do
                        if not autoCollectEnabled then break end
                        if v:IsA("ProximityPrompt") and v.Parent then
                             -- Try to treat the parent as the "item"
                             tryCollectItem(v.Parent)
                        end
                    end
                    task.wait(1)
                end
            end)
        end
    end,
})

FarmTab:Space()

FarmTab:Button({
    Title = "Refresh Mob List",
    Icon = "solar:SolarSquareTransferHorizontalBold",
    Callback = refreshMobs
})

mobDropdownFarm = FarmTab:Dropdown({
    Title = "Select Mob to Auto TP",
    Values = mobNames,
    Callback = function(v)
        if type(v) == "table" then v = v[1] end
        selectedMob = v
    end
})

local m1Toggle = FarmTab:Toggle({
    Title = "Auto M1",
    Callback = function(val)
        autoM1 = val
        if val then
            task.spawn(function()
                local vim = game:GetService("VirtualInputManager")
                while autoM1 do
                    -- Try VirtualInputManager click
                    vim:SendMouseButtonEvent(0, 0, 0, true, game, 1)
                    task.wait()
                    vim:SendMouseButtonEvent(0, 0, 0, false, game, 1)
                    
                    -- Fallback: Activate tool directly if click doesn't work for some tools
                    if player.Character then
                        local tool = player.Character:FindFirstChildWhichIsA("Tool")
                        if tool then
                            tool:Activate()
                        end
                    end
                    task.wait(0.1)
                end
            end)
        end
    end
})

local skillsToggle = FarmTab:Toggle({
    Title = "Auto Skills",
    Callback = function(val)
        autoSkills = val
        if val then
            task.spawn(function()
                local vim = game:GetService("VirtualInputManager")
                while autoSkills do
                     for _, kName in ipairs(selectedSkills) do
                         if not autoSkills then break end
                         local k = Enum.KeyCode[kName]
                         if k then
                             vim:SendKeyEvent(true, k, false, game)
                             task.wait()
                             vim:SendKeyEvent(false, k, false, game)
                             task.wait(0.1)
                         end
                     end
                     task.wait(0.5)
                end
            end)
        end
    end
})

FarmTab:Toggle({
    Title = "Auto TP to Mob",
    Callback = function(val)
        autoTPMob = val
        
        if val then
            task.spawn(function()
                while autoTPMob do
                    if selectedMob and mobCache[selectedMob] then
                        local targetPart = mobCache[selectedMob]
                        local offset = CFrame.new(0, tpDistance, 0)
                        if tpDirection == "Horizontal" then
                            offset = CFrame.new(0, -tpDistance, 0)
                            -- Optional: Rotate to face up? Usually standard 'Under' farm is just position.
                            -- If user means "Lying down horizontally", we might need rotation.
                            -- But "hitbox touches" implies standard proximity.
                            -- We will stick to position first.
                        elseif tpDirection == "Behind" then
                            offset = CFrame.new(0, 0, tpDistance)
                        elseif tpDirection == "Front" then
                            offset = CFrame.new(0, 0, -tpDistance)
                        end
                        
                        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                             player.Character.HumanoidRootPart.CFrame = targetPart.CFrame * offset
                        end
                    end
                    task.wait()
                end
            end)
        end
    end
})

-- Settings Tab
local SettingsTab = Window:Tab({
    Title = "Settings",
    Icon = "solar:SolarSquareTransferHorizontalBold",
    IconColor = Yellow,
    IconShape = "Square",
})

SettingsTab:Slider({
    Title = "TP Distance",
    Step = 1,
    Value = {
        Min = 0,
        Max = 20,
        Default = 3,
    },
    Callback = function(v)
        tpDistance = v
    end
})

SettingsTab:Dropdown({
    Title = "TP Direction",
    Values = {"Up", "Horizontal", "Behind", "Front"},
    Default = 1, -- Index of default value
    Callback = function(v)
        tpDirection = v
    end
})

SettingsTab:Dropdown({
    Title = "Select Skills",
    Multi = true,
    Required = false,
    Values = {"Z", "X", "C", "V", "E", "R", "T", "Y", "Q", "F", "G", "H"},
    Default = {"E", "R", "T", "Y", "H", "G", "Q"},
    Callback = function(val)
        selectedSkills = val
    end
})

SettingsTab:Space()

SettingsTab:Button({
    Title = "Save Settings",
    Icon = "solar:FolderWithFilesBold",
    Callback = saveSettings
})

SettingsTab:Button({
    Title = "Load Settings",
    Icon = "solar:SolarSquareTransferHorizontalBold",
    Callback = loadSettings
})

-- Auto Load Logic
local ok, err = pcall(loadSettings)
if not ok then warn("AutoLoad error:", err) end

-- Auto Save Logic
task.spawn(function()
    while true do
        task.wait(10)
        saveSettings(true) -- silent save
    end
end)

-- Player tab
local PlayerTab = Window:Tab({
    Title = "Player",
    Icon = "solar:CheckSquareBold",
    IconColor = Purple,
    IconShape = "Square",
})

PlayerTab:Slider({
    Title = "Speed",
    Desc = "Walkspeed",
    Color = Red,
    Step = 1,
    Value = {
        Min = 20,
        Max = 700,
        Default = 20,
    },
    Callback = function(value)
        targetWalkspeed = value
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.WalkSpeed = value
        end
    end,
})

PlayerTab:Toggle({
    Title = "Keep Speed",
    Callback = function(value)
        keepSpeed = value
        task.spawn(function()
            while keepSpeed do
                if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.WalkSpeed ~= targetWalkspeed then
                    player.Character.Humanoid.WalkSpeed = targetWalkspeed
                end
                task.wait()
            end
        end)
    end,
})

PlayerTab:Space()

PlayerTab:Slider({
    Title = "Jumppower",
    Color = Blue,
    Step = 1,
    Value = {
        Min = 50,
        Max = 700,
        Default = 50,
    },
    Callback = function(value)
        targetJump = value
        if player.Character and player.Character:FindFirstChild("Humanoid") then
            player.Character.Humanoid.JumpPower = value
        end
    end,
})

PlayerTab:Toggle({
    Title = "Keep Jumppower",
    Callback = function(value)
        keepJump = value
        task.spawn(function()
            while keepJump do
                if player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.JumpPower ~= targetJump then
                    player.Character.Humanoid.JumpPower = targetJump
                end
                task.wait()
            end
        end)
    end,
})

PlayerTab:Space()

PlayerTab:Button({
    Title = "TP Tool",
    Icon = "solar:HamburgerMenuBold",
    Callback = function()
        local tpTool = Instance.new("Tool")
        tpTool.RequiresHandle = false
        tpTool.Name = "Click Teleport"
        tpTool.ToolTip = "Teleports you to where you click."
        tpTool.CanBeDropped = false
        tpTool.Activated:Connect(function()
            local pos = mouse.Hit + Vector3.new(0, 3, 0)
            local cf = CFrame.new(pos.X, pos.Y, pos.Z, select(4, player.Character.HumanoidRootPart.CFrame:components()))
            player.Character.HumanoidRootPart.CFrame = cf
            local sound = Instance.new("Sound")
            sound.Name = "tpsfx"
            sound.Volume = 4
            sound.Parent = player.PlayerGui
            sound.SoundId = "rbxassetid://5124453445"
            sound.TimePosition = 0
            sound.Playing = true
            task.wait(1)
            sound:Destroy()
        end)
        tpTool.Parent = player.Backpack
    end,
})

PlayerTab:Toggle({
    Title = "T To TP",
    Callback = function(value)
        tToTP = value
    end,
})

game:GetService("UserInputService").InputBegan:Connect(function(input, processed)
    if processed then
        return
    end
    if input.KeyCode == Enum.KeyCode.T and tToTP then
        local pos = mouse.Hit + Vector3.new(0, 3, 0)
        local cf = CFrame.new(pos.X, pos.Y, pos.Z, select(4, player.Character.HumanoidRootPart.CFrame:components()))
        player.Character.HumanoidRootPart.CFrame = cf
        local sound = Instance.new("Sound")
        sound.Name = "tpsfx"
        sound.Volume = 4
        sound.Parent = player.PlayerGui
        sound.SoundId = "rbxassetid://5124453445"
        sound.TimePosition = 0
        sound.Playing = true
        task.wait(1)
        sound:Destroy()
    end
end)

PlayerTab:Space()

PlayerTab:Button({
    Title = "Hide Username",
    Icon = "solar:CheckSquareBold",
    Callback = function()
        if player.Character then
            for _, inst in ipairs(player.Character:GetDescendants()) do
                if (inst:IsA("TextLabel") or inst:IsA("TextButton")) and inst.Text == player.Name then
                    inst.Text = ""
                end
            end
        end
    end,
})


